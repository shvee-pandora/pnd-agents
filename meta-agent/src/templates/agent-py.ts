import { AgentConfig, TOOL_DESCRIPTIONS, type AvailableTool } from "../types/agent-config.js";

function toPascalCase(str: string): string {
  return str
    .split("_")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join("");
}

function toSnakeCase(str: string): string {
  return str.toLowerCase().replace(/[^a-z0-9]/g, "_");
}

export function generateAgentPy(config: AgentConfig): string {
  const className = toPascalCase(config.name) + "Agent";
  const isReadOnly = config.permissionLevel === "read_only";
  
  const toolImports = generateToolImports(config.allowedTools);
  const toolMethods = generateToolMethods(config.allowedTools, isReadOnly);
  const runMethod = generateRunMethod(config);
  
  return `"""
${config.displayName}

${config.description}

This agent was generated by the PND Meta-Agent.
Permission Level: ${config.permissionLevel}
Execution Environment: ${config.executionEnvironment}
Memory Enabled: ${config.memoryEnabled}
"""

import os
import json
import logging
from typing import Dict, List, Any, Optional
from dataclasses import dataclass, field
from datetime import datetime
from pathlib import Path

${toolImports}

logger = logging.getLogger("pnd_agents.${config.name}")


@dataclass
class ${className}Config:
    """Configuration for ${config.displayName}."""
    ${generateConfigFields(config)}


@dataclass
class ${className}Result:
    """Result from ${config.displayName} execution."""
    status: str  # success, error, partial
    data: Dict[str, Any] = field(default_factory=dict)
    recommendations: List[str] = field(default_factory=list)
    error: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        return {
            "status": self.status,
            "data": self.data,
            "recommendations": self.recommendations,
            "error": self.error,
        }


class ${className}:
    """
    ${config.displayName}
    
    ${config.responsibility}
    
    Permission Level: ${config.permissionLevel.toUpperCase()}
    ${isReadOnly ? "This agent is READ-ONLY and cannot modify any files or state." : "This agent has READ-WRITE permissions."}
    """
    
    # Permission constraints (enforced at runtime)
    PERMISSION_LEVEL = "${config.permissionLevel}"
    IS_READ_ONLY = ${isReadOnly ? "True" : "False"}
    ALLOWED_TOOLS = ${JSON.stringify(config.allowedTools)}
    
    def __init__(self, config: Optional[${className}Config] = None):
        """
        Initialize the ${config.displayName}.
        
        Args:
            config: Optional configuration for the agent.
        """
        self.config = config or ${className}Config()
        self._validate_permissions()
    
    def _validate_permissions(self):
        """Validate that the agent's permissions are correctly configured."""
        if self.IS_READ_ONLY:
            write_tools = ["filesystem_write", "git_operations", "command_runner"]
            for tool in self.ALLOWED_TOOLS:
                if tool in write_tools:
                    raise ValueError(
                        f"Read-only agent cannot use write tool: {tool}"
                    )
    
${toolMethods}

${runMethod}


def run(context: Dict[str, Any]) -> Dict[str, Any]:
    """
    Entry point for workflow integration.
    
    Args:
        context: Workflow context containing task description and metadata.
        
    Returns:
        Result dictionary with status and data.
    """
    agent = ${className}()
    result = agent.run(context)
    return result.to_dict()
`;
}

function generateToolImports(tools: AvailableTool[]): string {
  const imports: string[] = [];
  
  if (tools.includes("filesystem_read") || tools.includes("filesystem_write")) {
    imports.push("# Filesystem operations available via Path and os modules");
  }
  
  if (tools.includes("test_runner")) {
    imports.push("import subprocess");
  }
  
  if (tools.includes("http_client")) {
    imports.push("# HTTP client: use httpx or requests");
    imports.push("try:");
    imports.push("    import httpx");
    imports.push("except ImportError:");
    imports.push("    httpx = None");
  }
  
  return imports.join("\n");
}

function generateConfigFields(config: AgentConfig): string {
  const fields: string[] = [];
  
  if (config.outputFormat === "report" || config.outputFormat === "markdown") {
    fields.push('output_format: str = "' + config.outputFormat + '"');
  }
  
  if (config.memoryEnabled) {
    fields.push("memory_enabled: bool = True");
    fields.push('memory_path: str = "/tmp/pnd_agent_memory.json"');
  }
  
  if (config.executionEnvironment !== "both") {
    fields.push(`execution_environment: str = "${config.executionEnvironment}"`);
  }
  
  // Add tool-specific config fields
  if (config.allowedTools.includes("test_runner")) {
    fields.push('test_command: str = "npm test"');
    fields.push('coverage_command: str = "npm test -- --coverage"');
  }
  
  if (config.allowedTools.includes("filesystem_read")) {
    fields.push('root_path: str = "."');
    fields.push('file_patterns: List[str] = field(default_factory=lambda: ["*.ts", "*.tsx", "*.js", "*.jsx"])');
  }
  
  if (fields.length === 0) {
    fields.push("pass  # No additional configuration needed");
  }
  
  return fields.join("\n    ");
}

function generateToolMethods(tools: AvailableTool[], isReadOnly: boolean): string {
  const methods: string[] = [];
  
  if (tools.includes("filesystem_read")) {
    methods.push(`
    def _read_file(self, file_path: str) -> str:
        """Read a file from the filesystem."""
        path = Path(file_path)
        if not path.exists():
            raise FileNotFoundError(f"File not found: {file_path}")
        return path.read_text()
    
    def _list_files(self, directory: str, pattern: str = "*") -> List[str]:
        """List files in a directory matching a pattern."""
        path = Path(directory)
        if not path.exists():
            return []
        return [str(f) for f in path.glob(pattern)]
`);
  }
  
  if (tools.includes("filesystem_write") && !isReadOnly) {
    methods.push(`
    def _write_file(self, file_path: str, content: str) -> None:
        """Write content to a file."""
        if self.IS_READ_ONLY:
            raise PermissionError("Read-only agent cannot write files")
        path = Path(file_path)
        path.parent.mkdir(parents=True, exist_ok=True)
        path.write_text(content)
`);
  }
  
  if (tools.includes("test_runner")) {
    methods.push(`
    def _run_tests(self, command: Optional[str] = None) -> Dict[str, Any]:
        """Run test suite and return results."""
        cmd = command or self.config.test_command
        try:
            result = subprocess.run(
                cmd.split(),
                capture_output=True,
                text=True,
                timeout=300,
            )
            return {
                "success": result.returncode == 0,
                "stdout": result.stdout,
                "stderr": result.stderr,
                "return_code": result.returncode,
            }
        except subprocess.TimeoutExpired:
            return {
                "success": False,
                "error": "Test execution timed out",
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
            }
`);
  }
  
  if (tools.includes("coverage_analyzer")) {
    methods.push(`
    def _analyze_coverage(self, coverage_path: str = "coverage/coverage-summary.json") -> Dict[str, Any]:
        """Analyze test coverage from a coverage report."""
        try:
            path = Path(coverage_path)
            if not path.exists():
                return {"error": f"Coverage file not found: {coverage_path}"}
            
            with open(path) as f:
                coverage_data = json.load(f)
            
            total = coverage_data.get("total", {})
            return {
                "lines": total.get("lines", {}).get("pct", 0),
                "statements": total.get("statements", {}).get("pct", 0),
                "functions": total.get("functions", {}).get("pct", 0),
                "branches": total.get("branches", {}).get("pct", 0),
            }
        except Exception as e:
            return {"error": str(e)}
`);
  }
  
  if (tools.includes("code_parser")) {
    methods.push(`
    def _parse_code(self, file_path: str) -> Dict[str, Any]:
        """Parse source code and extract structure."""
        import re
        
        content = self._read_file(file_path)
        
        # Extract functions
        function_pattern = re.compile(
            r'(?:export\\s+)?(?:async\\s+)?function\\s+(\\w+)|'
            r'(?:export\\s+)?const\\s+(\\w+)\\s*=\\s*(?:async\\s*)?\\([^)]*\\)\\s*(?::\\s*\\w+)?\\s*=>'
        )
        functions = []
        for match in function_pattern.finditer(content):
            func_name = match.group(1) or match.group(2)
            if func_name:
                functions.append(func_name)
        
        # Extract classes
        class_pattern = re.compile(r'(?:export\\s+)?class\\s+(\\w+)')
        classes = [m.group(1) for m in class_pattern.finditer(content)]
        
        return {
            "file": file_path,
            "functions": functions,
            "classes": classes,
            "lines": len(content.split("\\n")),
        }
`);
  }
  
  return methods.join("\n");
}

function generateRunMethod(config: AgentConfig): string {
  const isReadOnly = config.permissionLevel === "read_only";
  
  return `
    def run(self, context: Dict[str, Any]) -> ${toPascalCase(config.name)}AgentResult:
        """
        Execute the agent's main task.
        
        Args:
            context: Context dictionary containing:
                - task_description: Description of the task
                - input_data: Input data for the agent
                - metadata: Additional metadata
                
        Returns:
            ${toPascalCase(config.name)}AgentResult with status and data.
        """
        task_description = context.get("task_description", "")
        input_data = context.get("input_data", {})
        metadata = context.get("metadata", {})
        
        logger.info(f"Starting ${config.displayName}: {task_description[:50]}...")
        
        try:
            # Main agent logic
            result_data = self._execute_task(task_description, input_data, metadata)
            
            return ${toPascalCase(config.name)}AgentResult(
                status="success",
                data=result_data,
                recommendations=result_data.get("recommendations", []),
            )
        except Exception as e:
            logger.error(f"${config.displayName} failed: {e}")
            return ${toPascalCase(config.name)}AgentResult(
                status="error",
                error=str(e),
            )
    
    def _execute_task(
        self,
        task_description: str,
        input_data: Dict[str, Any],
        metadata: Dict[str, Any],
    ) -> Dict[str, Any]:
        """
        Execute the main task logic.
        
        Override this method to implement custom agent behavior.
        """
${generateTaskLogic(config)}
`;
}

function generateTaskLogic(config: AgentConfig): string {
  const lines: string[] = [];
  
  lines.push("result = {}");
  lines.push("recommendations = []");
  lines.push("");
  
  if (config.allowedTools.includes("filesystem_read")) {
    lines.push("# Analyze files in the target directory");
    lines.push('target_path = input_data.get("path", self.config.root_path)');
    lines.push("files = self._list_files(target_path)");
    lines.push('result["files_analyzed"] = len(files)');
    lines.push("");
  }
  
  if (config.allowedTools.includes("test_runner")) {
    lines.push("# Run tests if requested");
    lines.push('if input_data.get("run_tests", False):');
    lines.push('    test_results = self._run_tests()');
    lines.push('    result["test_results"] = test_results');
    lines.push("");
  }
  
  if (config.allowedTools.includes("coverage_analyzer")) {
    lines.push("# Analyze coverage if available");
    lines.push('coverage_path = input_data.get("coverage_path", "coverage/coverage-summary.json")');
    lines.push("coverage = self._analyze_coverage(coverage_path)");
    lines.push('result["coverage"] = coverage');
    lines.push("");
    lines.push("# Generate coverage recommendations");
    lines.push('if coverage.get("lines", 100) < 100:');
    lines.push(`    recommendations.append(f"Line coverage is {coverage.get('lines')}%. Target is 100%.")`);
    lines.push('if coverage.get("branches", 100) < 100:');
    lines.push(`    recommendations.append(f"Branch coverage is {coverage.get('branches')}%. Target is 100%.")`);
    lines.push("");
  }
  
  lines.push('result["recommendations"] = recommendations');
  lines.push("return result");
  
  return lines.map(line => "        " + line).join("\n");
}
